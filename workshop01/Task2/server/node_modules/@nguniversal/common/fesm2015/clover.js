import { ɵgetDOM, DOCUMENT, ɵPLATFORM_SERVER_ID } from '@angular/common';
import { Injectable, Inject, Optional, APP_ID, PLATFORM_ID, NgModule, ApplicationRef } from '@angular/core';
import { ɵSharedStylesHost, ɵescapeHtml, ɵDomSharedStylesHost, BrowserModule, TransferState, makeStateKey, BrowserTransferStateModule } from '@angular/platform-browser';
import { filter, take, mapTo, tap } from 'rxjs/operators';
import { HttpResponse, HttpHeaders, HTTP_INTERCEPTORS } from '@angular/common/http';
import { of } from 'rxjs';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class SSRStylesHost extends ɵSharedStylesHost {
    constructor(doc, appId) {
        var _a;
        super();
        this.doc = doc;
        this.appId = appId;
        this._styleNodes = new Set();
        this.head = this.doc.querySelector('head');
        const styles = (_a = this.head) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`style[ng-style='${this.appId}']`);
        if (styles === null || styles === void 0 ? void 0 : styles.length) {
            const items = Array.from(styles);
            this._styleNodesInDOM = new Map(items.map((el) => [el.textContent, el]));
        }
    }
    _addStyle(style) {
        var _a, _b;
        const element = (_a = this._styleNodesInDOM) === null || _a === void 0 ? void 0 : _a.get(style);
        if (element) {
            if (typeof ngDevMode !== undefined && ngDevMode) {
                element.setAttribute('_ng-style-re-used', '');
            }
            (_b = this._styleNodesInDOM) === null || _b === void 0 ? void 0 : _b.delete(style);
            this._styleNodes.add(element);
            return;
        }
        const el = ɵgetDOM().createElement('style');
        el.textContent = style;
        if (this.appId) {
            el.setAttribute('ng-style', this.appId);
        }
        if (this.head) {
            this.head.appendChild(el);
        }
        this._styleNodes.add(el);
    }
    onStylesAdded(additions) {
        additions.forEach((style) => this._addStyle(style));
    }
    addHost(_hostNode) {
        // stub
    }
    removeHost(_hostNode) {
        // stub
    }
    ngOnDestroy() {
        this._styleNodes.forEach((styleNode) => styleNode.remove());
    }
}
SSRStylesHost.decorators = [
    { type: Injectable }
];
SSRStylesHost.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [APP_ID,] }] }
];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RendererModule {
    constructor(applicationRef, transferState, appId) {
        this.applicationRef = applicationRef;
        this.transferState = transferState;
        this.appId = appId;
        if (typeof ngRenderMode !== 'undefined' && ngRenderMode) {
            ngRenderMode = {
                getSerializedState: () => this.transferState ? ɵescapeHtml(this.transferState.toJson()) : undefined,
                appId: this.appId,
                getWhenStable: () => this.applicationRef.isStable
                    .pipe(filter((isStable) => isStable), take(1), mapTo(undefined))
                    .toPromise(),
            };
        }
    }
    static forRoot() {
        return {
            ngModule: RendererModule,
            providers: [
                ...(typeof ngRenderMode !== 'undefined' && ngRenderMode
                    ? [
                        { provide: PLATFORM_ID, useValue: ɵPLATFORM_SERVER_ID },
                        { provide: SSRStylesHost, useClass: SSRStylesHost, deps: [DOCUMENT, APP_ID] },
                    ]
                    : [{ provide: SSRStylesHost, useClass: SSRStylesHost, deps: [DOCUMENT] }]),
                { provide: ɵSharedStylesHost, useExisting: SSRStylesHost },
                { provide: ɵDomSharedStylesHost, useClass: SSRStylesHost },
            ],
        };
    }
}
RendererModule.decorators = [
    { type: NgModule, args: [{
                exports: [BrowserModule],
                imports: [],
                providers: [],
            },] }
];
RendererModule.ctorParameters = () => [
    { type: ApplicationRef },
    { type: TransferState, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [APP_ID,] }] }
];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TransferHttpCacheInterceptor {
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter((isStable) => isStable), take(1), tap(() => (this.isCacheActive = false)))
            .subscribe();
    }
    makeCacheKey(method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        const encodedParams = params
            .keys()
            .sort()
            .map((k) => `${k}=${params.getAll(k)}`)
            .join('&');
        const key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    intercept(req, next) {
        if (!this.isCacheActive || !['GET', 'HEAD'].includes(req.method)) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        const storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            const response = this.transferState.get(storeKey, {});
            return of(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        // Request not found in cache. Make the request and cache it.
        const httpEvent = next.handle(req);
        return httpEvent.pipe(tap((event) => {
            var _a;
            if (event instanceof HttpResponse) {
                this.transferState.set(storeKey, {
                    body: event.body,
                    headers: this.getHeaders(event.headers),
                    status: event.status,
                    statusText: event.statusText,
                    url: (_a = event.url) !== null && _a !== void 0 ? _a : '',
                });
            }
        }));
    }
    getHeaders(headers) {
        const headersMap = {};
        for (const key of headers.keys()) {
            const value = headers.getAll(key);
            if (typeof value === 'string') {
                headersMap[key] = value;
            }
        }
        return headersMap;
    }
}
TransferHttpCacheInterceptor.decorators = [
    { type: Injectable }
];
TransferHttpCacheInterceptor.ctorParameters = () => [
    { type: ApplicationRef },
    { type: TransferState }
];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TransferHttpCacheModule {
}
TransferHttpCacheModule.decorators = [
    { type: NgModule, args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ],
            },] }
];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */

export { RendererModule, TransferHttpCacheModule, SSRStylesHost as ɵnguniversal_modules_common_clover_clover_a, TransferHttpCacheInterceptor as ɵnguniversal_modules_common_clover_clover_b };
//# sourceMappingURL=clover.js.map
